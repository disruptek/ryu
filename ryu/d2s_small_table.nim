## Copyright 2018 Ulf Adams
##
## The contents of this file may be used under the terms of the Apache License,
## Version 2.0.
##
##    (See accompanying file LICENSE-Apache or copy at
##     http://www.apache.org/licenses/LICENSE-2.0)
##
## Alternatively, the contents of this file may be used under the terms of
## the Boost Software License, Version 1.0.
##    (See accompanying file LICENSE-Boost or copy at
##     https://www.boost.org/LICENSE_1_0.txt)
##
## Unless required by applicable law or agreed to in writing, this software
## is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
## KIND, either express or implied.

import ryu/common

when false:
  # Defines HAS_UINT128 and uint128_t if applicable.
  import ryu/d2s_intrinsics
else:
  import compiler/int128

## These tables are generated by PrintDoubleLookupTable.
const
  ryuDoublePow5InvBitCount* {.intdefine.} = 125
  ryuDoublePow5BitCount* {.intdefine.} = 125

  ryuDoublePow5InvSplit*: seq[DubDub64] = @[
    (                    1'u64, 2305843009213693952'u64 ),
    (  5955668970331000884'u64, 1784059615882449851'u64 ),
    (  8982663654677661702'u64, 1380349269358112757'u64 ),
    (  7286864317269821294'u64, 2135987035920910082'u64 ),
    (  7005857020398200553'u64, 1652639921975621497'u64 ),
    ( 17965325103354776697'u64, 1278668206209430417'u64 ),
    (  8928596168509315048'u64, 1978643211784836272'u64 ),
    ( 10075671573058298858'u64, 1530901034580419511'u64 ),
    (   597001226353042382'u64, 1184477304306571148'u64 ),
    (  1527430471115325346'u64, 1832889850782397517'u64 ),
    ( 12533209867169019542'u64, 1418129833677084982'u64 ),
    (  5577825024675947042'u64, 2194449627517475473'u64 ),
    ( 11006974540203867551'u64, 1697873161311732311'u64 )
  ]

  ryuDoublePow5InvSplit2*: seq[DubDub64] = @[
    (                    1'u64, 2305843009213693952'u64 ),
    (  5955668970331000884'u64, 1784059615882449851'u64 ),
    (  8982663654677661702'u64, 1380349269358112757'u64 ),
    (  7286864317269821294'u64, 2135987035920910082'u64 ),
    (  7005857020398200553'u64, 1652639921975621497'u64 ),
    ( 17965325103354776697'u64, 1278668206209430417'u64 ),
    (  8928596168509315048'u64, 1978643211784836272'u64 ),
    ( 10075671573058298858'u64, 1530901034580419511'u64 ),
    (   597001226353042382'u64, 1184477304306571148'u64 ),
    (  1527430471115325346'u64, 1832889850782397517'u64 ),
    ( 12533209867169019542'u64, 1418129833677084982'u64 ),
    (  5577825024675947042'u64, 2194449627517475473'u64 ),
    ( 11006974540203867551'u64, 1697873161311732311'u64 )
  ]
  ryuPow5InvOffsets*: array[19, uint32] = [
    0x54544554'u32,
    0x04055545, 0x10041000, 0x00400414, 0x40010000, 0x41155555, 0x00000454,
    0x00010044, 0x40000000, 0x44000041, 0x50454450, 0x55550054, 0x51655554,
    0x40004000, 0x01000001, 0x00010500, 0x51515411, 0x05555554, 0x00000000
  ]
  ryuDoublePow5Split2*: seq[DubDub64] = @[
    (                    0'u64, 1152921504606846976'u64 ),
    (                    0'u64, 1490116119384765625'u64 ),
    (  1032610780636961552'u64, 1925929944387235853'u64 ),
    (  7910200175544436838'u64, 1244603055572228341'u64 ),
    ( 16941905809032713930'u64, 1608611746708759036'u64 ),
    ( 13024893955298202172'u64, 2079081953128979843'u64 ),
    (  6607496772837067824'u64, 1343575221513417750'u64 ),
    ( 17332926989895652603'u64, 1736530273035216783'u64 ),
    ( 13037379183483547984'u64, 2244412773384604712'u64 ),
    (  1605989338741628675'u64, 1450417759929778918'u64 ),
    (  9630225068416591280'u64, 1874621017369538693'u64 ),
    (   665883850346957067'u64, 1211445438634777304'u64 ),
    ( 14931890668723713708'u64, 1565756531257009982'u64 )
  ]
  ryuPow5Offsets*: array[21, uint32] = [
    0x00000000'u32,
    0x00000000, 0x00000000, 0x00000000, 0x40000000, 0x59695995, 0x55545555,
    0x56555515, 0x41150504, 0x40555410, 0x44555145, 0x44504540, 0x45555550,
    0x40004000, 0x96440440'u32, # nim defect
                            0x55565565, 0x54454045, 0x40154151, 0x55559155,
    0x51405555, 0x00000105
  ]

  ryuDoublePow5Table*: array[26, uint64] = [
    1'u64, 5'u64, 25'u64, 125'u64, 625'u64, 3125'u64, 15625'u64, 78125'u64,
    390625'u64, 1953125'u64, 9765625'u64, 48828125'u64, 244140625'u64,
    1220703125'u64, 6103515625'u64, 30517578125'u64, 152587890625'u64,
    762939453125'u64, 3814697265625'u64, 19073486328125'u64,
    95367431640625'u64, 476837158203125'u64, 2384185791015625'u64,
    11920928955078125'u64, 59604644775390625'u64, 298023223876953125'u64,
    # ryu comments this out...
    #, 1490116119384765625'u64
  ]
  ryuPow5TableSize* = ryuDoublePow5Table.len

#when declaredInScope(Int128):
when true:

  proc doubleComputePow5*(i: uint32; result: var DubDub64) {.inline.} =
    ## Computes 5^i in the form required by Ryu, and stores it in the given
    ## pointer.
    let
      base: uint32 = i div ryuPow5TableSize
      base2: uint32 = base * ryuPow5TableSize
      offset: uint32 = i - base2
      mul: DubDub64 = ryuDoublePow5Split2[base]
    if offset == 0:
      result[0] = mul[0]
      result[1] = mul[1]
      return
    let
      m: uint64 = ryuDoublePow5Table[offset]
      b0: Int128 = m.toInt128 * mul[0].toInt128
      b2: Int128 = m.toInt128 * mul[1].toInt128
      delta: uint32 = uint32(pow5Bits(i.int32) - pow5Bits(base2.int32))
      shiftedSum: Int128 = (b0 shr delta.int) + (b2 shl (64 - delta.int)) + ((ryuPow5Offsets[i div 16] shr ((i mod 16) shl 1)) and 3).toInt128
    result[0] = castToUInt64(shiftedSum)
    result[1] = castToUInt64(shiftedSum shr 64)

  proc doubleComputeInvPow5*(i: uint32; result: var DubDub64) {.inline.} =
    ## Computes 5^-i in the form required by Ryu, and stores it in the given
    ## pointer.
    let
      base: uint32 = (i + ryuPow5TableSize - 1) div ryuPow5TableSize
      base2: uint32 = base * ryuPow5TableSize
      offset: uint32 = base2 - i
      mul: DubDub64 = ryuDoublePow5InvSplit2[base] # 1/5^base2
    if offset == 0:
      result[0] = mul[0]
      result[1] = mul[1]
      return
    let
      m: uint64 = ryuDoublePow5Table[offset] # 5^offset
      b0: Int128 = m.toInt128 * (mul[0] - 1).toInt128
      b2: Int128 = m.toInt128 * (mul[1] - 0).toInt128 # 1/5^base2 * 5^offset
                                                      # = 1/5^(base2-offset)
                                                      # = 1/5^i
      delta: uint32 = uint32(pow5Bits(base2.int32) - pow5Bits(i.int32))
      shiftedSum: Int128 = ((b0 shr delta.int) + (b2 shl (64 - delta.int))) + 1 + ((ryuPow5InvOffsets[i div 16] shr ((i mod 16) shl 1)) and 3).toInt128
    result[0] = castToUInt64(shiftedSum)
    result[1] = castToUInt64(shiftedSum shr 64)

else:
  # we have no uint128

  proc doubleComputePow5*(i: uint32; result: var DubDub64) {.inline.} =
    ## Computes 5^i in the form required by Ryu, and stores it in the given
    ## pointer.
    let
      base: uint32 = i div ryuPow5TableSize
      base2: uint32 = base * ryuPow5TableSize
      offset: uint32 = i - base2
      mul: DubDub64 = ryuDoublePow5Split2[base]
    if offset == 0:
      result[0] = mul[0]
      result[1] = mul[1]
      return

    let
      m = ryuDoublePow5Table[offset]
    var
      high0: uint64
      high1: uint64
    let
      low0: uint64 = umul128(m, mul[0], addr high0)
      low1: uint64 = umul128(m, mul[1], addr high1)
      sum = high0 + low1
    if sum < high0:
      high1.inc # overflow into high1

    # high1 | sum | low0
    let
      delta: uint32 = pow5Bits(i) - pow5Bits(base2)
    result[0] = shiftRight128(low0, sum, delta) + ((ryuPow5Offsets[i div 16] shr ((i mod 16) shl 1)) and 3)
    result[1] = shiftRight128(sum, high1, delta)

  proc doubleComputeInvPow5*(i: uint32; result: var DubDub64) {.inline.} =
    ## Computes 5^-i in the form required by Ryu, and stores it in the given
    ## pointer.
    let
      base: uint32 = (i + ryuPow5TableSize - 1) div ryuPow5TableSize
      base2: uint32 = base * ryuPow5TableSize
      offset: uint32 = base2 - i
      mul: DubDub64 = ryuDoublePow5InvSplit2[base] # 1/5^base2
    if offset == 0:
      result[0] = mul[0]
      result[1] = mul[1]
      return
    let
      m: uint64 = ryuDoublePow5Table[offset]
    var
      high0: uint64
      high1: uint64
    let
      low0: uint64 = umul128(m, mul[0] - 1, addr high0)
      low1: uint64 = umul128(m, mul[1] - 0, addr high1)
      sum = high0 + low1
    if sum < high0:
      high1.inc # overflow into high1
    # high1 | sum | low0
    let
      delta: uint32 = pow5Bits(base2) - pow5Bits(i)
    result[0] = shiftRight128(low0, sum, delta) + 1 + ((ryuPow5InvOffsets[i div 16] shr ((i mod 16) shl 1)) and 3)
    result[1] = shiftRight128(sum, high1, delta)
